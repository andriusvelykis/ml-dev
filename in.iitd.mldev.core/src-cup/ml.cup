/** 
 * Standard ML grammar
 */

package in.iitd.mldev.core.parse;

import in.iitd.mldev.core.parse.ast.*;
import java.util.List;
import java.util.ArrayList;

action code {:
  /** Returns an empty list. */
  private <T> List<T> list () {return new ArrayList<T>();}
  
  /** Returns a list containing only the given object. */
  private <T> List<T> list (T o) {List<T> l = list(); append(l,o); return l;}
  
  /** Appends the given object to the end of the list. */
  private <T> List<T> append (List<T> l, T o) {l.add(o); return l;}
  
  /** Prepends the given object to the beginning of the list. */
  private <T> List<T> prepend (T o, List<T> l) {l.add(0,o); return l;}
  
  /** Concatenates two lists. */
  private <T> List<T> concat (List<T> l1, List<T> l2) {l1.addAll(l2); return l1;}
  
:}

parser code {:
  /** List of parse errors. */
  public List<java_cup.runtime.Symbol> parseErrors;
  
  /** This method is called when a syntax error has been detected
   * and recovery is about to be invoked. This parser adds
   * the offending token to the parseErrors list. */
  public void syntax_error (java_cup.runtime.Symbol token) {
    parseErrors.add(token);
  }
:}

init with {:
    parseErrors = new ArrayList<java_cup.runtime.Symbol>();
:}

// Terminals

	terminal String ID, TYVAR;
	terminal Integer INT;
	terminal Float REAL;
	terminal String STRING, CHAR;

	terminal ABSTYPE, AND, ANDALSO, AS, CASE, DATATYPE, DO,
		ELSE, END, EQTYPE, EXCEPTION, FN, FUN, FUNCTOR, FUNSIG, HANDLE,
		IF, IN, INCLUDE, INFIX, INFIXR, LAZY, LET, LOCAL, NONFIX,
		OF, OP, OPEN, ORELSE, RAISE, REC, SHARING, SIG, SIGNATURE,
		STRUCT, STRUCTURE, THEN, TYPE, VAL, WHERE, WHILE, WITH, WITHTYPE;

	terminal LPAREN, RPAREN, LBRACKET, LVECTOR, RBRACKET, LBRACE, RBRACE,
		DOT, COMMA, COLON, COLONGT, SEMIC, DOTDOTDOT, UNDER, BAR, EQUALS,
		DARROW, ARROW, HASH, ASTERISK;
	
// Non-terminals

	nonterminal ASTRoot sml;

	nonterminal Ident ident, ident1, ident2, tyvar, tycon,
		qident, qident1, qident2, longident2;
	nonterminal Exp exp, atexp;
	nonterminal Label label;
	nonterminal Match match;
	nonterminal Dec dec, topdec;
	nonterminal List<Bind> valbind, recvalbind, funbind, typebind,
		datatypebind, conbind, exnbind;
	nonterminal List<Clause> clauses;
	nonterminal Pat pat, atpat;
	nonterminal Field expfield, patfield, typefield;
	nonterminal Type type, attype;
	nonterminal Fixity fixity;
	
	nonterminal Str str, fctarg;
	nonterminal Sig sig;
	nonterminal Dec strdec, strdec_;
	nonterminal List<Bind> strbind, sigbind, fctbind, funsigbind;
	nonterminal Spec spec;
	
	nonterminal op_;
	nonterminal Type constraint;

	nonterminal String id1, id2;
	nonterminal List<Ident> qidents1, idents2,
		patheqn, tyvars, tyvarseq;
	nonterminal List<String> qualifier;
	nonterminal List<Field> exprecord, patrecord, typerecord;
	nonterminal List<Exp> expseq, exps, appexp;
	nonterminal List<Rule> rules;
	nonterminal List<Dec> decs, strdecs, strdecs_, topdecs;
	nonterminal List<Pat> pats, atpats, orpat;
	nonterminal List<Type> typetuple, types;
	nonterminal List<Str> fctargs;
	nonterminal List<Whspec> wherespecs;
	nonterminal List<Spec> specs;
	nonterminal List<Desc> strdesc, fctdesc, typedesc, valdesc, exndesc, sharingdesc,
		paramdescs;
	nonterminal Desc paramdesc;

// Precedences

	precedence nonassoc WITHTYPE;
	precedence left AND;
	precedence right ARROW;
	precedence right DARROW;
	precedence right BAR;
	precedence left DO;
	precedence left ELSE;
	precedence left RAISE;
	precedence right HANDLE;
	precedence left ORELSE;
	precedence left ANDALSO;
	precedence right AS;
	precedence right COLON;

// Grammar

	sml ::= topdecs:ds {: RESULT = new ASTRoot(ds) .mark(dsleft,dsright); :};

	// Basic rules
	
	id1 ::=
		ID:id {: RESULT = id; :} |
		ASTERISK {: RESULT = "*"; :};
	id2 ::=
		ID:id {: RESULT = id; :} |
		ASTERISK {: RESULT = "*"; :} |
		EQUALS {: RESULT = "="; :};

	ident ::= ID:id {: RESULT = new Ident(id) .mark(idleft,idright); :};
	ident1 ::= id1:id {: RESULT = new Ident(id) .mark(idleft,idright); :};
	ident2 ::= id2:id {: RESULT = new Ident(id) .mark(idleft,idright); :};

	tyvar ::= TYVAR:tv {: RESULT = new Ident(tv) .mark(tvleft,tvright); :};

	qualifier ::=
			{: RESULT = list(); :} |
		qualifier:q ID:id DOT {: RESULT = prepend(id,q); :};
	
	qident ::= qualifier:q ID:id {: RESULT = new Ident(q,id) .mark(qleft,idright); :};
	qident1 ::= qualifier:q id1:id {: RESULT = new Ident(q,id) .mark(qleft,idright); :};
	qident2 ::= qualifier:q id2:id {: RESULT = new Ident(q,id) .mark(qleft,idright); :};
	longident2 ::= ID:id1 DOT qualifier:q id2:id2 {: RESULT = new Ident(append(q,id1),id2) .mark(id1left,id2right); :};

	qidents1 ::=
		qident1:id {: RESULT = list(id); :} |
		qidents1:ids qident1:id {: RESULT = append(ids,id); :};

	idents2 ::=
		ident2:id {: RESULT = list(id); :} |
		idents2:ids ident2:id {: RESULT = append(ids,id); :};
	
	tyvars ::=
			{: RESULT = list(); :} |
		tyvar:tv {: RESULT = list(tv); :} |
		LPAREN tyvarseq:tvs RPAREN {: RESULT = tvs; :};
	
	tyvarseq ::=
		tyvar:tv {: RESULT = list(tv); :} |
		tyvarseq:tvs COMMA tyvar:tv {: RESULT = append(tvs,tv); :};

	constraint ::=
		{: RESULT = null; :} |
		COLON type:t {: RESULT = t; :};
	
	op_ ::= | OP;

	// Expressions

	atexp ::=
		ident2:id
			{: RESULT = new VarExp(id) .mark(idleft,idright); :} |
		OP:o ident2:id
			{: RESULT = new VarExp(id, true) .mark(oleft,idright); :} |
		longident2:id
			{: RESULT = new VarExp(id) .mark(idleft,idright); :} |
		INT:i
			{: RESULT = new IntExp(i) .mark(ileft,iright); :} |
		REAL:r
			{: RESULT = new RealExp(r) .mark(rleft,rright); :} |
		STRING:s
			{: RESULT = new StringExp(s) .mark(sleft,sright); :} |
		CHAR:c
			{: RESULT = new CharExp(c) .mark(cleft,cright); :} |
		HASH:h label:l
			{: RESULT = new SelectorExp(l) .mark(hleft,lright); :} |
		LBRACE:l exprecord:er RBRACE:r
			{: RESULT = new RecordExp(er) .mark(lleft,rright); :} |
		LBRACE:l RBRACE:r
			{: RESULT = new RecordExp() .mark(lleft,rright); :} |
		LPAREN:l RPAREN:r
			{: RESULT = new UnitExp() .mark(lleft,rright); :} |
		LPAREN:l exp:e RPAREN:r
			{: RESULT = e .mark(lleft,rright); :} |
		LPAREN:l expseq:es RPAREN:r
			{: RESULT = new SeqExp(es) .mark(lleft,rright); :} |
		LPAREN:l exp:e COMMA exps:es RPAREN:r
			{: RESULT = new TupleExp(prepend(e,es)) .mark(lleft,rright); :} |
		LBRACKET:l exps:es RBRACKET:r
			{: RESULT = new ListExp(es) .mark(lleft,rright); :} |
		LBRACKET:l RBRACKET:r
			{: RESULT = new ListExp() .mark(lleft,rright); :} |
		LVECTOR:l exps:es RBRACKET:r
			{: RESULT = new VectorExp(es) .mark(lleft,rright); :} |
		LVECTOR:l RBRACKET:r
			{: RESULT = new VectorExp() .mark(lleft,rright); :} |
		LET:l decs:ds IN exp:e END:en
			{: RESULT = new LetExp(ds,e) .mark(lleft,enright); :} |
		LET:l decs:ds IN expseq:es END:e
			{: RESULT = new LetExp(ds, new SeqExp(es).mark(esleft,esright)) .mark(lleft,eright); :};

	label ::=
		ident1:id {: RESULT = new IdentLabel(id) .mark(idleft,idright); :} |
		INT:i {: RESULT = new IntLabel(i) .mark(ileft,iright); :};

	exprecord ::=
		expfield:f {: RESULT = list(f); :} |
		exprecord:r COMMA expfield:f {: RESULT = append(r,f); :};
				
	expfield ::= label:l EQUALS exp:e {: RESULT = new ExpField(l,e) .mark(lleft,eright); :};

	expseq ::=
		exp:e1 SEMIC exp:e2 {: RESULT = append(list(e1),e2); :} |
		expseq:s SEMIC exp:e {: RESULT = append(s,e); :};

	exps ::=
		exp:e {: RESULT = list(e); :} |
		exps:es COMMA exp:e {: RESULT = append(es,e); :};

	appexp ::=
		atexp:e {: RESULT = list(e); :} |
		appexp:ae atexp:e {: RESULT = append(ae,e); :};

	exp ::=
		exp:e HANDLE match:m
			{: RESULT = new HandleExp(e, m) .mark(eleft,mright); :} |
		exp:e1 ORELSE exp:e2
			{: RESULT = new OrelseExp(e1,e2) .mark(e1left,e2right); :} |
		exp:e1 ANDALSO exp:e2
			{: RESULT = new AndalsoExp(e1,e2) .mark(e1left,e2right); :} |
		exp:e COLON type:t
			{: RESULT = new TypedExp(e,t) .mark(eleft,tright); :} |
		appexp:ae
			{: RESULT = new FlatAppExp(ae) .mark(aeleft,aeright); :} |
		FN:f match:m
			{: RESULT = new FnExp(m) .mark(fleft,mright); :} |
		CASE:c exp:e OF match:m
			{: RESULT = new CaseExp(e,m) .mark(cleft,mright); :} |
		WHILE:w exp:e1 DO exp:e2
			{: RESULT = new WhileExp(e1,e2) .mark(wleft,e2right); :} |
		IF:i exp:e1 THEN exp:e2 ELSE exp:e3
			{: RESULT = new IfExp(e1,e2,e3) .mark(ileft,e3right); :} |
		RAISE:r exp:e
			{: RESULT = new RaiseExp(e) .mark(rleft,eright); :} |
		error:e
			{: RESULT = new ErrorExp() .mark(eleft,eright); :};

	// Matches

	match ::= rules:rs {: RESULT = new Match(rs) .mark(rsleft,rsright); :};

	rules ::=
		pat:p DARROW exp:e
			{: RESULT = list(new Rule(p,e) .mark(pleft,eright)); :} |
		rules:r1 BAR rules:r2
			{: RESULT = concat(r1,r2); :};

	// Declarations

	decs ::=

			{: RESULT = list(); :} |
		LOCAL:l decs:ds1 IN decs:ds2 END:e
			{: RESULT = list(new LocalDec(ds1,ds2) .mark(lleft,eright)); :} |
		decs:ds dec:d
			{: RESULT = append(ds,d); :} |
		decs:ds error:e
			{: RESULT = append(ds, new ErrorDec() .mark(eleft,eright)); :} |
		decs:ds SEMIC
			{: RESULT = ds; :};

	dec ::=
		VAL:v valbind:vb
			{: RESULT = new ValDec(vb) .mark(vleft,vbright); :} |
		VAL:v tyvarseq:tvs valbind:vb
			{: RESULT = new ValDec(vb,tvs) .mark(vleft,vbright); :} |
		VAL:v REC recvalbind:rvb
			{: RESULT = new RecValDec(rvb) .mark(vleft,rvbright); :} |
		VAL:v REC tyvarseq:tvs recvalbind:rvb
			{: RESULT = new RecValDec(rvb,tvs) .mark(vleft,rvbright); :} |
		FUN:f funbind:fb
			{: RESULT = new FunDec(fb) .mark(fleft,fbright); :} |
		TYPE:t typebind:tb
			{: RESULT = new TypeDec(tb) .mark(tleft,tbright); :} |
		DATATYPE:d datatypebind:db
			{: RESULT = new DatatypeDec(db) .mark(dleft,dbright); :} |
		DATATYPE:d datatypebind:db WITHTYPE typebind:tb
			{: RESULT = new DatatypeDec(db,tb) .mark(dleft,tbright); :} |
		ABSTYPE:a datatypebind:db WITH decs:ds END:e
			{: RESULT = new AbstypeDec(db,ds) .mark(aleft,eright); :} |
		ABSTYPE:a datatypebind:db WITHTYPE typebind:tb WITH decs:ds END:e
			{: RESULT = new AbstypeDec(db,tb,ds) .mark(aleft,eright); :} |
		EXCEPTION:e exnbind:eb
			{: RESULT = new ExnDec(eb) .mark(eleft,ebright); :} |
		OPEN:o qidents1:ids
			{: RESULT = new OpenDec(ids) .mark(oleft,idsright); :} |
		fixity:f idents2:ids
			{: RESULT = new FixityDec(f,ids) .mark(fleft,idsright); :};
			

	valbind ::=
		pat:p EQUALS exp:e
			{: RESULT = list(new ValBind(p,e) .mark(pleft,eright)); :} |
		LAZY:l pat:p EQUALS exp:e
			{: RESULT = list(new ValBind(p,e,true) .mark(lleft,eright)); :} |
		valbind:vb1 AND valbind:vb2
			{: RESULT = concat(vb1,vb2); :};
	
	recvalbind ::=
		op_:o ident1:id constraint:c EQUALS exp:e
			{: RESULT = list(new RecValBind(id,c,e) .mark(oleft,eright)); :} |
		LAZY:l op_ ident1:id constraint:c EQUALS exp:e
			{: RESULT = list(new RecValBind(id,c,e,true) .mark(lleft,eright)); :} |
		recvalbind:vb1 AND recvalbind:vb2
			{: RESULT = concat(vb1,vb2); :};
	
	funbind ::=
		clauses:cs
			{: RESULT = list(new FunBind(cs) .mark(csleft,csright)); :} |
		LAZY:l clauses:cs
			{: RESULT = list(new FunBind(cs,true) .mark(lleft,csright)); :} |
		funbind:fb1 AND funbind:fb2
			{: RESULT = concat(fb1,fb2); :};
	
	clauses ::=
		atpats:ps constraint:c EQUALS exp:e
			{: RESULT = list(new Clause(ps,c,e) .mark(psleft,eright)); :} |
		clauses:c1 BAR clauses:c2
			{: RESULT = concat(c1,c2); :};
	
	typebind ::=
		tyvars:tvs ident:id EQUALS type:t
			{: RESULT = list(new TypeBind(tvs,id,t) .mark(tvsleft,tright)); :} |
		typebind:tb1 AND typebind:tb2
			{: RESULT = concat(tb1,tb2); :};
	
	datatypebind ::=
		tyvars:tvs ident:id EQUALS conbind:cbs
			{: RESULT = list(new DatatypeBind(tvs,id,cbs) .mark(tvsleft,cbsright)); :} |
		LAZY:l tyvars:tvs ident:id EQUALS conbind:cbs
			{: RESULT = list(new DatatypeBind(tvs,id,cbs,true) .mark(lleft,cbsright)); :} |
		tyvars:tvs ident:id EQUALS DATATYPE tycon:tc
			{: RESULT = list(new DatatypeBind(tvs,id,tc) .mark(tvsleft,tcright)); :} |
		LAZY:l tyvars:tvs ident:id EQUALS DATATYPE tycon:tc
			{: RESULT = list(new DatatypeBind(tvs,id,tc,true) .mark(lleft,tcright)); :} |
		datatypebind:db1 AND datatypebind:db2
			{: RESULT = concat(db1,db2); :};
	
	conbind ::=
		op_:o ident2:id
			{: RESULT = list(new ConBind(id) .mark(oleft,idright)); :} |
		op_:o ident2:id OF type:t
			{: RESULT = list(new ConBind(id,t) .mark(oleft,tright)); :} |
		conbind:cb1 BAR conbind:cb2
			{: RESULT = concat(cb1,cb2); :};
	
	exnbind ::=
		op_:o ident2:id
			{: RESULT = list(new ExnBind(id) .mark(oleft,idright));
				id.mark(idleft,idright); :} |
		op_:o ident2:id OF type:t
			{: RESULT = list(new ExnBind(id,t) .mark(oleft,tright)); 
				id.mark(idleft, idright); t.mark(tleft,tright); :} |
		op_:o ident2:id1 EQUALS qident2:id2
			{: RESULT = list(new ExnBind(id1,id2) .mark(oleft,id2right));
				id1.mark(id1left,id1right); id2.mark(id2left,id2right); :} |
		exnbind:eb1 AND exnbind:eb2
			{: RESULT = concat(eb1,eb2); :};

	fixity ::=
		INFIX:f {: RESULT = new Fixity(Fixity.LEFT) .mark(fleft,fright); :} |
		INFIX:f INT:i {: RESULT = new Fixity(Fixity.LEFT, i) .mark(fleft,iright); :} |
		INFIXR:f {: RESULT = new Fixity(Fixity.RIGHT) .mark(fleft,fright); :} |
		INFIXR:f INT:i {: RESULT = new Fixity(Fixity.RIGHT, i) .mark(fleft,iright); :} |
		NONFIX:f {: RESULT = new Fixity(Fixity.NONE) .mark(fleft,fright); :};
			
	// Patterns

	atpat ::=
		ident1:id
			{: RESULT = new VarPat(id) .mark(idleft,idright); :} |
		OP:o ident2:id
			{: RESULT = new VarPat(id, true) .mark(oleft,idright); :} |
		longident2:id
			{: RESULT = new VarPat(id) .mark(idleft,idright); :} |
		INT:i
			{: RESULT = new IntPat(i) .mark(ileft,iright); :} |
		STRING:s
			{: RESULT = new StringPat(s) .mark(sleft,sright); :} |
		CHAR:c
			{: RESULT = new CharPat(c) .mark(cleft,cright); :} |
		UNDER:u
			{: RESULT = new WildPat() .mark(uleft,uright); :} |
		LBRACKET:l RBRACKET:r
			{: RESULT = new ListPat() .mark(lleft,rright); :} |
		LBRACKET:l pats:ps RBRACKET:r
			{: RESULT = new ListPat(ps) .mark(lleft,rright); :} |
		LVECTOR:l RBRACKET:r
			{: RESULT = new VectorPat() .mark(lleft,rright); :} |
		LVECTOR:l pats:ps RBRACKET:r
			{: RESULT = new ListPat(ps) .mark(lleft,rright); :} |
		LBRACE:l RBRACE:r
			{: RESULT = new RecordPat() .mark(lleft,rright); :} |
		LBRACE:l patrecord:r RBRACE:rb
			{: RESULT = new RecordPat(r) .mark(lleft,rbright); :} |
		LPAREN:l RPAREN:r
			{: RESULT = new UnitPat() .mark(lleft,rright); :} |
		LPAREN:l pat:p COMMA pats:ps RPAREN:r
			{: RESULT = new TuplePat(prepend(p,ps)) .mark(lleft,rright); :} |
		LPAREN:l orpat:op RPAREN:r
			{: RESULT = new OrPat(op) .mark(lleft,rright); :} |
		LPAREN:l pat:p RPAREN:r
			{: RESULT = p .mark(lleft,rright); :};

	patrecord ::=
		patfield:f {: RESULT = list(f); :} |
		patfield:f COMMA patrecord:r {: RESULT = prepend(f,r); :} |
		DOTDOTDOT {: RESULT = list(); :};
	
	patfield ::=
		label:l EQUALS pat:p
			{: RESULT = new PatField(l,p) .mark(lleft,pright); :} |
		ident:id constraint:c
			{: RESULT = new VarPatField(id,c) .mark(idleft,cright); :} |
		ident:id constraint:c AS pat:p
			{: RESULT = new VarPatField(id,c,p) .mark(idleft,pright); :};
	
	orpat ::=
		pat:p1 BAR pat:p2 {: RESULT = append(list(p1),p2); :} |
		orpat:op BAR pat:p {: RESULT = append(op,p); :};
	
	pats ::=
		pat:p {: RESULT = list(p); :} |
		pats:ps COMMA pat:p {: RESULT = append(ps,p); :};

	atpats ::=
		atpat:p {: RESULT = list(p); :} |
		atpats:ps atpat:p {: RESULT = append(ps,p); :};

	pat ::=
		atpats:ps
			{: RESULT = new FlatConPat(ps) .mark(psleft,psright); :} |
		pat:p1 AS pat:p2
			{: RESULT = new LayeredPat(p1,p2) .mark(p1left,p2right); :} |
		pat:p COLON type:t
			{: RESULT = new TypedPat(p,t) .mark(pleft,tright); :} |
		error:e
			{: RESULT = new ErrorPat() .mark(eleft,eright); :};

	// Types
	
	type ::=
		typetuple:tt
			{: RESULT = new TupleType(tt) .mark(ttleft,ttright); :} |
		type:t1 ARROW type:t2
			{: RESULT = new FnType(t1,t2) .mark(t1left,t2right); :} |
		attype:t
			{: RESULT = t; :} |
		error:e
			{: RESULT = new ErrorType() .mark(eleft,eright); :};
	
	attype ::=
		tyvar:tv
			{: RESULT = new VarType(tv) .mark(tvleft,tvright); :} |
		LBRACE:l typerecord:tr RBRACE:r
			{: RESULT = new RecordType(tr) .mark(lleft,rright); :} |
		LBRACE:l RBRACE:r
			{: RESULT = new RecordType() .mark(lleft,rright); :} |
		LPAREN:l type:t COMMA types:ts RPAREN tycon:tc
			{: RESULT = new ConType(prepend(t,ts),tc) .mark(lleft,tcright); :} |
		attype:t tycon:tc
			{: RESULT = new ConType(t,tc) .mark(tleft,tcright); :} |
		tycon:tc
			{: RESULT = new ConType(tc) .mark(tcleft,tcright); :} |
		LPAREN:l type:t RPAREN:r
			{: RESULT = t .mark(lleft,rright); :};
	
	tycon ::=
		qident:id {: RESULT = id; :};
	
	typetuple ::=
		attype:t1 ASTERISK attype:t2 {: RESULT = append(list(t1),t2); :} |
		typetuple:tt ASTERISK attype:t {: RESULT = append(tt,t); :};

	typerecord ::=
		typefield:f {: RESULT = list(f); :} |
		typerecord:r COMMA typefield:f {: RESULT = append(r,f); :};
				
	typefield ::= label:l COLON type:t {: RESULT = new TypeField(l,t) .mark(lleft,tright); :};
	
	types ::=
		type:t {: RESULT = list(t); :} |
		types:ts COMMA type:t {: RESULT = append(ts,t); :};

	// Modules
	
	str ::=
		STRUCT:s strdecs:sds END:e
			{: RESULT = new BaseStr(sds) .mark(sleft,eright); :} |
		qident2:id
			{: RESULT = new VarStr(id) .mark(idleft,idright); :} |
		qident2:id fctargs:fas
			{: RESULT = new AppStr(id,fas) .mark(idleft,fasright); :} |
		LET:l strdecs:sds IN str:s END:e
			{: RESULT = new LetStr(sds,s) .mark(lleft,eright); :} |
		str:s COLON sig:sig
			{: RESULT = new SignedStr(s,sig) .mark(sleft,sigright); :} |
		str:s COLONGT sig:sig
			{: RESULT = new SignedStr(s,sig,true) .mark(sleft,sigright); :} |
		error
			{: RESULT = new ErrorStr(); :};
	
	fctarg ::=
		LPAREN str:s RPAREN {: RESULT = s; :} |
		LPAREN:l strdecs_:sds RPAREN:r {: RESULT = new BaseStr(sds) .mark(lleft,rright); :};
	
	fctargs ::=
		fctarg:fa {: RESULT = list(fa); :} |
		fctargs:fas fctarg:fa {: RESULT = append(fas,fa); :};
	
	strdecs ::=
		
			{: RESULT = list(); :} |
		strdecs:sds strdec:sd
			{: RESULT = append(sds,sd); :} |
		strdecs:sds SEMIC
			{: RESULT = sds; :};
	
	strdecs_ ::=
		
			{: RESULT = list(); :} |
		strdecs_:sds strdec_:sd
			{: RESULT = append(sds,sd); :} |
		strdecs_:sds SEMIC
			{: RESULT = sds; :};
	
	strdec_ ::=
		dec:d
			{: RESULT = d; :} |
		STRUCTURE:s strbind:sb
			{: RESULT = new StrDec(sb) .mark(sleft,sbright); :} |
		FUNCTOR:f fctbind:fb
			{: RESULT = new FctDec(fb) .mark(fleft,fbright); :} |
		LOCAL:l strdecs:sd1 IN strdecs:sd2 END:e
			{: RESULT = new LocalDec(sd1,sd2) .mark(lleft,eright); :};
	
	strdec ::=
		strdec_:sd
			{: RESULT = sd; :} |
		error
			{: RESULT = new ErrorDec(); :};
		
	strbind ::=
		ident2:id EQUALS str:s
			{: RESULT = list(new StrBind(id,s) .mark(idleft,sright)); :} |
		ident2:id COLON sig:sig EQUALS str:s
			{: RESULT = list(new StrBind(id,s,sig) .mark(idleft,sright)); :} |
		ident2:id COLONGT sig:sig EQUALS str:s
			{: RESULT = list(new StrBind(id,s,sig,true) .mark(idleft,sright)); :} |
		strbind:sb1 AND strbind:sb2
			{: RESULT = concat(sb1,sb2); :};
	
	fctbind ::=
		ident2:id paramdescs:pds EQUALS str:s
			{: RESULT = list(new FctBind(id,pds,s) .mark(idleft,sright)); :} |
		ident2:id paramdescs:pds COLON sig:sig EQUALS str:s
			{: RESULT = list(new FctBind(id,pds,sig,s) .mark(idleft,sright)); :} |
		ident2:id paramdescs:pds COLONGT sig:sig EQUALS str:s
			{: RESULT = list(new FctBind(id,pds,sig,s,true) .mark(idleft,sright)); :} |
		fctbind:fb1 AND fctbind:fb2
			{: RESULT = concat(fb1,fb2); :};
				
	sig ::=
		SIG:s specs:ss END:e
			{: RESULT = new BaseSig(ss) .mark(sleft,eright); :} |
		ident2:id
			{: RESULT = new VarSig(id) .mark(idleft,idright); :} |
		sig:s WHERE wherespecs:ws
			{: RESULT = new WhereSig(s,ws) .mark(sleft,wsright); :} |
		error
			{: RESULT = new ErrorSig(); :};
	
	wherespecs ::=
		TYPE:ty tyvars:tvs qident2:id EQUALS type:t
			{: RESULT = list(new TypeWhspec(tvs,id,t) .mark(tyleft,tright)); :} |
		qident2:id1 EQUALS qident2:id2
			{: RESULT = list(new StructWhspec(id1,id2) .mark(id1left,id2right)); :} |
		wherespecs:ws1 AND wherespecs:ws2
			{: RESULT = concat(ws1,ws2); :};

	sigbind ::=
		ident2:id EQUALS sig:s
			{: RESULT = list(new SigBind(id,s) .mark(idleft,sright)); :} |
		sigbind:sb1 AND sigbind:sb2
			{: RESULT = concat(sb1,sb2); :};
	
	funsigbind ::=
		ident2:id paramdescs:pds EQUALS sig:s
			{: RESULT = list(new FunsigBind(id,pds,s) .mark(idleft,sright)); :} |
		funsigbind:fsb1 AND funsigbind:fsb2
			{: RESULT = concat(fsb1,fsb2); :};
		
	specs ::=
			{: RESULT = list(); :} |
		spec:s specs:ss {: RESULT = prepend(s,ss); :} |
		SEMIC specs:ss {: RESULT = ss; :};

	spec ::=
		STRUCTURE:s strdesc:sd
			{: RESULT = new StrSpec(sd) .mark(sleft,sdright); :} |
		FUNCTOR:f fctdesc:fd
			{: RESULT = new FctSpec(fd) .mark(fleft,fdright); :} |
		DATATYPE:d datatypebind:db
			{: RESULT = new DatatypeSpec(db) .mark(dleft,dbright); :} |
		DATATYPE:d datatypebind:db WITHTYPE typebind:tb
			{: RESULT = new DatatypeSpec(db,tb) .mark(dleft,tbright); :} |
		TYPE:t typedesc:td
			{: RESULT = new TypeSpec(td) .mark(tleft,tdright); :} |
		EQTYPE:eq typedesc:td
			{: RESULT = new TypeSpec(td,true) .mark(eqleft,tdright); :} |
		VAL:v valdesc:vd
			{: RESULT = new ValSpec(vd) .mark(vleft,vdright); :} |
		EXCEPTION:e exndesc:ed
			{: RESULT = new ExnSpec(ed) .mark(eleft,edright); :} |
		fixity:f idents2:ids
			{: RESULT = new FixitySpec(f,ids) .mark(fleft,idsright); :} |
		SHARING:s sharingdesc:sd
			{: RESULT = new SharingSpec(sd) .mark(sleft,sdright); :} |
		INCLUDE:i sig:s
			{: RESULT = new IncludeSpec(s) .mark(ileft,sright); :} |
		INCLUDE:i ident2:id idents2:ids
			{: RESULT = new IncludeSpec(prepend(id,ids)) .mark(ileft,idsright); :};
	
	strdesc ::=
		ident2:id COLON sig:s
			{: RESULT = list(new StrDesc(id,s) .mark(idleft,sright)); :} |
		ident2:id1 COLON sig:s EQUALS qident2:id2
			{: RESULT = list(new StrDesc(id1,s,id2) .mark(id1left,id2right)); :} |
		strdesc:sd1 AND strdesc:sd2
			{: RESULT = concat(sd1,sd2); :};
	
	fctdesc ::=
		ident2:id1 paramdescs:pds COLON ident2:id2
			{: RESULT = list(new FctDesc(id1,pds,id2) .mark(id1left,id2right)); :} |
		fctdesc:fd1 AND fctdesc:fd2
			{: RESULT = concat(fd1,fd2); :};
	
	typedesc ::=
		tyvars:tvs ident:id
			{: RESULT = list(new TypeDesc(tvs,id) .mark(tvsleft,idright)); :} |
		tyvars:tvs ident:id EQUALS type:t
			{: RESULT = list(new TypeDesc(tvs,id,t) .mark(tvsleft,tright)); :} |
		typedesc:td1 AND typedesc:td2
			{: RESULT = concat(td1,td2); :};
	
	valdesc ::=
		op_ ident:id COLON type:t
			{: RESULT = list(new ValDesc(id,t) .mark(idleft,tright)); :} |
		valdesc:vd1 AND valdesc:vd2
			{: RESULT = concat(vd1,vd2); :};

	exndesc ::=
		ident:id
			{: RESULT = list(new ExnDesc(id) .mark(idleft,idright)); :} |
		ident:id OF type:t
			{: RESULT = list(new ExnDesc(id,t) .mark(idleft,tright)); :} |
		exndesc:ed1 AND exndesc:ed2
			{: RESULT = concat(ed1,ed2); :};
	
	sharingdesc ::=
		patheqn:pe {: RESULT = list(new SharingDesc(pe,true) .mark(peleft,peright)); :} |
		TYPE:t patheqn:pe {: RESULT = list(new SharingDesc(pe,false) .mark(tleft,peright)); :} |
		sharingdesc:sd1 AND sharingdesc:sd2 {: RESULT = concat(sd1,sd2); :};

	patheqn ::=
		qident2:id1 EQUALS qident2:id2 {: RESULT = append(list(id1),id2); :} |
		patheqn:pe EQUALS qident2:id {: RESULT = append(pe,id); :};
	
	paramdesc ::=
		ident:id COLON sig:s
			{: RESULT = new ParamDesc(id,s) .mark(idleft,sright); :} |
		specs:ss
			{: RESULT = new ParamDesc(new BaseSig(ss).mark(ssleft,ssright)); :};
	
	paramdescs ::=
			{: RESULT = list(); :} |
		paramdescs:pds LPAREN paramdesc:pd RPAREN {: RESULT = append(pds,pd); :};
	
	// Top-level declarations
	
	topdecs ::=
			{: RESULT = list(); :} |
		exp:e
			{: RESULT = list(new ExpDec(e) .mark(eleft,eright)); :} |
		topdecs:tds topdec:td
			{: RESULT = append(tds,td); :} |
		topdecs:tds SEMIC
			{: RESULT = tds; :};
	
	topdec ::=
		strdec_:sd
			{: RESULT = sd; :} |
		SIGNATURE:s sigbind:sb
			{: RESULT = new SigDec(sb) .mark(sleft,sbright); :} |
		FUNSIG:f funsigbind:fsb
			{: RESULT = new FunsigDec(fsb) .mark(fleft,fsbright); :} |
		SEMIC:s exp:e
			{: RESULT = new ExpDec(e) .mark(sleft,eright); :};
